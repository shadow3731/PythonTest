
from typing import Optional, Union


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if (
            root is None
            or (root.left is None and root.right is None)
        ):
            return True
        
        def define_max_depth(root: Optional[TreeNode]) -> int:
            if (
                root is None
                or (root.left is None and root.right is None)
            ):
                return 0
            
            left_depth = 0
            right_depth = 0
            
            if root.left is not None:
                left_depth += define_max_depth(root.left)
                
            if root.right is not None:
                right_depth += define_max_depth(root.right)
                
            if left_depth > right_depth:
                return left_depth
            else:
                return right_depth
        
        left_depth = define_max_depth(root.left)
        right_depth = define_max_depth(root.right)
        
        print(left_depth, right_depth)
        if abs(right_depth - left_depth) > 1:
            return False
        else:
            return True
        
        
        # if root is None:
        #     return True

        # left_root_balanced = None
        # right_root_balanced = None
        
        # if root.left is not None:
        #     if root.left.left is not None and root.left.right is not None:
        #         left_is_balanced = self.isBalanced(root.left)
                
        #     elif root.left.left is None and root.left.right is None:
        
        
        
        # if (
        #     root is None 
        #     or (root.left is None and root.right is None)
        # ):
        #     return True
        
        # if (
        #     (root.left is None and root.right is not None)
        #     or (root.left is not None and root.right is None)
        # ):
        #     return False
        
        # left_is_balanced = self.isBalanced(root.left)
        # right_is_balanced = self.isBalanced(root.right)
        
        # if (
        #     left_is_balanced is True 
        #     and right_is_balanced is True
        # ):
        #     return True
        # else:
        #     return False
        
        
        
        
        
        # left_height = 0
        # right_height = 0
        
        # def calculate_height(root: Optional[TreeNode], heght_val: int) -> int:
        #     while True:
                
        
        # def inorderTraversal(root: Optional[TreeNode]) -> int:
        #     # Check if "root" is empty
        #     if root is None or root.val is None:
        #         return 0
            
        #     # Check if "root" contains a left subtree
        #     if root.left is not None:
        #         # Make the subtree as a "root", work with him and 
        #         # insert all the got values
        #         amount += inorderTraversal(root.left)
            
        #     # Check if "root" contains a right subtree
        #     if root.right is not None:
        #         # Make the subtree as a "root", work with him and 
        #         # insert all the got values
        #         amount += inorderTraversal(root.right)
                
        #     # Return the result list
        #     return amount
            
        # left_nodes_amount = inorderTraversal(root.left)
        # right_nodes_amount = inorderTraversal(root.right)
        
        # if abs(right_nodes_amount - left_nodes_amount) > 1:
        #     return False
        # else:
        #     return True
        
if __name__ == '__main__':
    root = TreeNode(
        3,
        TreeNode(9),
        TreeNode(20, TreeNode(15), TreeNode(7))
    )
    print(Solution().isBalanced(root))
    
    root = TreeNode(
        1,
        TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(4)), TreeNode(3)),
        TreeNode(2)
    )
    print(Solution().isBalanced(root))